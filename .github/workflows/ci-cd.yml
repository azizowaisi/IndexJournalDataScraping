name: CI/CD - Journal Index Data Scraping

on:
  push:
    branches: [master]   # Deploy when master branch is updated (including PR merges)
  pull_request:
    types: [closed]
    branches: [master]   # Also trigger when PR is closed (merged or closed)

jobs:
  build-deploy:
    runs-on: ubuntu-latest
    # Only run if this is a push to master OR a merged PR to master
    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.merged == true)

    steps:
      # 1. Checkout repo
      - name: Checkout code
        uses: actions/checkout@v4

      # 2. Set up Node.js 22
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'

      # 3. Install dependencies
      - name: Install dependencies
        run: npm ci

      # 4. Run tests
      - name: Run tests
        run: npm test

      # 5. Build application
      - name: Build application
        run: npm run build

      # 6. Install Serverless Framework v4
      - name: Install Serverless Framework v4
        run: npm install -g serverless@4

      # 7. Deploy using Serverless Framework with authentication
      - name: Deploy to AWS
        env:
          SERVERLESS_ACCESS_KEY: ${{ secrets.SERVERLESS_ACCESS_KEY }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          # S3 Configuration
          S3_BUCKET_NAME: ${{ secrets.S3_BUCKET_NAME }}
          S3_DEPLOYMENT_BUCKET: ${{ secrets.S3_DEPLOYMENT_BUCKET }}
          # SQS Configuration
          SQS_SCRAPING_QUEUE_URL: ${{ secrets.SQS_SCRAPING_QUEUE_URL }}
          SQS_SCRAPING_QUEUE_ARN: ${{ secrets.SQS_SCRAPING_QUEUE_ARN }}
          SQS_INTEGRATION_QUEUE_URL: ${{ secrets.SQS_INTEGRATION_QUEUE_URL }}
          SQS_INTEGRATION_QUEUE_ARN: ${{ secrets.SQS_INTEGRATION_QUEUE_ARN }}
        run: |
          echo "$SERVERLESS_ACCESS_KEY" | serverless login --key
          
          # Function to check CloudFormation stack status
          check_stack_status() {
            local stack_name="index-journals-data-scraping-prod"
            local status=$(aws cloudformation describe-stacks --stack-name $stack_name --region $AWS_REGION --query 'Stacks[0].StackStatus' --output text 2>/dev/null || echo "STACK_NOT_FOUND")
            echo "Current stack status: $status"
            echo $status
          }
          
          # Wait for stack to be in a deployable state
          echo "Checking CloudFormation stack status..."
          max_attempts=30
          attempt=1
          
          while [ $attempt -le $max_attempts ]; do
            status=$(check_stack_status)
            echo "Attempt $attempt/$max_attempts - Stack status: $status"
            
            case $status in
              "CREATE_COMPLETE"|"UPDATE_COMPLETE"|"UPDATE_ROLLBACK_COMPLETE"|"STACK_NOT_FOUND")
                echo "Stack is in a deployable state: $status"
                break
                ;;
              "UPDATE_IN_PROGRESS"|"CREATE_IN_PROGRESS")
                echo "Stack is still updating, waiting 30 seconds..."
                sleep 30
                ;;
              *)
                echo "Stack is in state: $status - proceeding with deployment"
                break
                ;;
            esac
            
            attempt=$((attempt + 1))
          done
          
          if [ $attempt -gt $max_attempts ]; then
            echo "Timeout waiting for stack to be ready. Proceeding with deployment..."
          fi
          
          # Deploy with retry mechanism
          max_deploy_attempts=3
          deploy_attempt=1
          
          while [ $deploy_attempt -le $max_deploy_attempts ]; do
            echo "Deployment attempt $deploy_attempt/$max_deploy_attempts"
            
            if sls deploy --stage prod --region $AWS_REGION; then
              echo "Deployment successful!"
              break
            else
              echo "Deployment failed on attempt $deploy_attempt"
              
              if [ $deploy_attempt -lt $max_deploy_attempts ]; then
                echo "Waiting 60 seconds before retry..."
                sleep 60
              else
                echo "All deployment attempts failed"
                exit 1
              fi
            fi
            
            deploy_attempt=$((deploy_attempt + 1))
          done

  sonarcloud:
    name: SonarCloud Analysis
    runs-on: ubuntu-latest
    needs: [build-deploy]
    if: github.ref == 'refs/heads/master' && github.event_name == 'push'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Shallow clones should be disabled for better analysis

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run tests with coverage
        run: npm run test:coverage

      - name: SonarCloud Scan
        uses: SonarSource/sonarqube-scan-action@v5.0.0
        with:
          args: >
            -Dsonar.projectKey=${{ secrets.SONAR_PROJECT_KEY }}
            -Dsonar.organization=${{ secrets.SONAR_ORGANIZATION }}
            -Dsonar.host.url=https://sonarcloud.io
            -Dsonar.javascript.lcov.reportPaths=coverage/lcov.info
            -Dsonar.coverage.exclusions=**/*.test.js,**/__mocks__/**,**/jest.setup.js
            -Dsonar.ci.analysis=true
            -Dsonar.ci.analysis.force=true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
