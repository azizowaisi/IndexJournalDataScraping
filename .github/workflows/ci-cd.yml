name: CI/CD - Deploy to Production

on:
  push:
    branches:
      - master

env:
  NODE_VERSION: '22'

jobs:
  # Step 1: Lint and Format Check
  lint:
    name: Lint and Format Check
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run ESLint
        run: npm run lint

      - name: Run Prettier check
        run: npm run format:check

  # Step 2: Run Tests with Coverage (after lint)
  test:
    name: Run Tests with Coverage
    runs-on: ubuntu-latest
    needs: [lint]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run tests with coverage
        run: npm run test:coverage

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage/lcov.info
          flags: unittests
          name: codecov-production
          fail_ci_if_error: false

  # Step 3: Security Scan (parallel with tests)
  security:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: [lint]
    permissions:
      security-events: write
      contents: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run npm audit
        run: npm audit --audit-level=moderate
        continue-on-error: true

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

  # Step 4: SonarCloud Analysis (after tests)
  sonarcloud:
    name: SonarCloud Analysis
    runs-on: ubuntu-latest
    needs: [test]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run tests with coverage
        run: npm run test:coverage

      - name: SonarCloud Scan
        uses: SonarSource/sonarqube-scan-action@v6.0.0
        with:
          args: >
            -Dsonar.projectKey=${{ secrets.SONAR_PROJECT_KEY }}
            -Dsonar.organization=${{ secrets.SONAR_ORGANIZATION }}
            -Dsonar.host.url=https://sonarcloud.io
            -Dsonar.javascript.lcov.reportPaths=coverage/lcov.info
            -Dsonar.coverage.exclusions=**/*.test.js,**/__mocks__/**,**/jest.setup.js
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

  # Step 5: Build Application (after tests and security)
  build:
    name: Build Application
    runs-on: ubuntu-latest
    needs: [test, security]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install production dependencies
        run: npm ci --omit=dev

      - name: Build application
        run: npm run build

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: production-build
          path: |
            src/
            package.json
            package-lock.json
            serverless.yml
          retention-days: 7

  # Step 6: Deploy to Production (after all checks pass)
  deploy:
    name: Deploy to AWS Production
    runs-on: ubuntu-latest
    needs: [build, sonarcloud]
    environment:
      name: production
      url: https://console.aws.amazon.com/lambda
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Install Serverless Framework
        run: npm install -g serverless@4

      - name: Deploy to AWS
        env:
          SERVERLESS_ACCESS_KEY: ${{ secrets.SERVERLESS_ACCESS_KEY }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          S3_BUCKET_NAME: ${{ secrets.S3_BUCKET_NAME }}
          S3_DEPLOYMENT_BUCKET: ${{ secrets.S3_DEPLOYMENT_BUCKET }}
          SQS_SCRAPING_QUEUE_URL: ${{ secrets.SQS_SCRAPING_QUEUE_URL }}
          SQS_SCRAPING_QUEUE_ARN: ${{ secrets.SQS_SCRAPING_QUEUE_ARN }}
          SQS_INTEGRATION_QUEUE_URL: ${{ secrets.SQS_INTEGRATION_QUEUE_URL }}
          SQS_INTEGRATION_QUEUE_ARN: ${{ secrets.SQS_INTEGRATION_QUEUE_ARN }}
        run: |
          echo "üîê Logging into Serverless Framework..."
          echo "$SERVERLESS_ACCESS_KEY" | serverless login --key

          echo "üìã Checking CloudFormation stack status..."
          check_stack_status() {
            local stack_name="index-journals-data-scraping-prod"
            local status=$(aws cloudformation describe-stacks --stack-name $stack_name --region $AWS_REGION --query 'Stacks[0].StackStatus' --output text 2>/dev/null || echo "STACK_NOT_FOUND")
            echo $status
          }

          max_attempts=30
          attempt=1

          while [ $attempt -le $max_attempts ]; do
            status=$(check_stack_status)
            echo "Attempt $attempt/$max_attempts - Stack status: $status"

            case $status in
              "CREATE_COMPLETE"|"UPDATE_COMPLETE"|"UPDATE_ROLLBACK_COMPLETE"|"STACK_NOT_FOUND")
                echo "‚úÖ Stack is ready for deployment"
                break
                ;;
              "UPDATE_IN_PROGRESS"|"CREATE_IN_PROGRESS")
                echo "‚è≥ Stack updating, waiting 30 seconds..."
                sleep 30
                ;;
              *)
                echo "Stack state: $status - proceeding anyway"
                break
                ;;
            esac

            attempt=$((attempt + 1))
          done

          echo "üöÄ Starting deployment to production..."
          max_deploy_attempts=3
          deploy_attempt=1

          while [ $deploy_attempt -le $max_deploy_attempts ]; do
            echo "Deployment attempt $deploy_attempt/$max_deploy_attempts"

            if sls deploy --stage prod --region $AWS_REGION; then
              echo "‚úÖ Deployment successful!"
              break
            else
              echo "‚ùå Deployment failed on attempt $deploy_attempt"

              if [ $deploy_attempt -lt $max_deploy_attempts ]; then
                echo "‚è≥ Waiting 60 seconds before retry..."
                sleep 60
              else
                echo "‚ùå All deployment attempts failed"
                exit 1
              fi
            fi

            deploy_attempt=$((deploy_attempt + 1))
          done

      - name: Verify Deployment
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: |
          echo "üîç Verifying Lambda function..."
          aws lambda get-function \
            --function-name index-journals-data-scraping-prod-scraping \
            --region $AWS_REGION \
            --query 'Configuration.{Name:FunctionName,Runtime:Runtime,State:State,LastModified:LastModified}' \
            --output table

      - name: Deployment Summary
        run: |
          echo ""
          echo "üéâ Deployment Summary"
          echo "===================="
          echo "Environment: Production"
          echo "Region: ${{ secrets.AWS_REGION }}"
          echo "Function: index-journals-data-scraping-prod-scraping"
          echo "S3 Bucket: ${{ secrets.S3_BUCKET_NAME }}"
          echo ""
          echo "‚úÖ Deployment completed successfully!"
          echo ""
          echo "View logs:"
          echo "aws logs tail /aws/lambda/index-journals-data-scraping-prod-scraping --follow"

  # Summary Job
  deployment-complete:
    name: ‚úÖ Deployment Complete
    runs-on: ubuntu-latest
    needs: [deploy]
    if: always()
    
    steps:
      - name: Final Status
        run: |
          if [[ "${{ needs.deploy.result }}" == "success" ]]; then
            echo "üéâ Production deployment completed successfully!"
          else
            echo "‚ùå Production deployment failed!"
            exit 1
          fi
